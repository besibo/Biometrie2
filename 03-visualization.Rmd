# Visualiser des données avec `ggplot2` {#viz}

Dans les chapitres \@ref(bases) et \@ref(dataset), nous avons vu ce qui me semble être les concepts essentiels avant de commencer à explorer en détail des données dans R. Les éléments de syntaxe abordés dans la section \@ref(code) sont nombreux et vous n'avez probablement pas tout retenu. C'est pourquoi je vous conseille de garder les tutoriels de DataCamp à portée de main afin de pouvoir refaire les parties que vous maîtrisez le moins. Ce n'est qu'en répétant plusieurs fois ces tutoriels que les choses seront vraiment comprises et que vous les retiendrez. Ainsi, si des éléments de code présentés ci-dessous vous semblent obscures, revenez en arrière : toutes les réponses à vos questions se trouvent probablement dans les chapitres précédents.

Après la découverte des bases du langage R, nous abordons maintenant les parties de ce livre qui concernent la "science des données" (ou "Data Science" pour nos amis anglo-saxons). Nous allons voir dans ce chapitre qu'outre les fonctions `View()` et `glimpse()`, l'exploration visuelle *via* la représentation graphique des données est un moyen indispensable et très puissant pour comprendre ce qui se passe dans un jeu de données. **La visualisation de vos données devrait toujours être un préambule à toute analyse statistique.**

La visualisation des données est en outre un excellent point de départ quand on découvre la programmation sous R, car ses bénéfices sont clairs et immédiats : vous pouvez créer des graphiques élégants et informatifs qui vous aident à comprendre les données. Dans ce chapitre, vous allez donc plonger dans l'art de la visualisation de données, en apprenant la structure de base des graphiques réalisés avec `ggplot2` qui permettent de transformer des données numériques et catégorielles en graphiques.

Toutefois, la visualisation seule ne suffit généralement pas. Il est en effet souvent nécessaire de transformer les données pour produire des représentations plus parlantes. Ainsi, dans les chapitres \@ref(tidyr) et \@ref(wrangling), vous découvrirez les verbes clés qui vous permettront de sélectionner des variables importantes, de filtrer les observations clés, de créer de nouvelles variables, de calculer des résumés, d'associer des tableaus ou de les remettre en forme.

C'est en combinant la transformation des données et les représentations graphiques avec votre curiosité et votre esprit critique, vous serez véritablement en mesure de réaliser l'analyse exploratoire de données, seul procédé permettant de poser des questions intéressantes et pertinentes sur les données et afin d'y répondre.


## Prérequis

Dans ce chapitre, nous aurons besoin des packages suivants :

```{r}
library(ggplot2)
library(nycflights13)
library(dplyr)
```

Si ce n'est pas déjà fait pensez à les installer avant de les charger en mémoire.

Au niveau le plus élémentaire, les graphiques permettent de comprendre comment les variables se comparent en termes de tendance centrale (à quel endroit les valeurs ont tendance à être localisées, regroupées) et leur dispersion (comment les données varient autour du centre). La chose la plus importante à savoir sur les graphiques est qu'ils doivent être créés pour que votre public (le prof qui vous évalue, le collègue avec qui vous collaborez, votre futur patron, etc.) comprenne bien les résultats et les informations que vous souhaitez transmettre. Il s'agit d'un exercice d'équilibriste : d'une part, vous voulez mettre en évidence autant de relations significatives et de résultats intéressants que possible, mais de l'autre, vous ne voulez pas en inclure trop, afin d'éviter de rendre votre graphique illisible ou de submerger votre public. Tout comme n'importe quel paragraphe de document écrit, un graphique doit permettre de **communiquer un message** (une idée forte, un résultat marquant, une hypothèse nouvelle, etc).

Comme nous le verrons, les graphiques nous aident également à repérer les tendances extrêmes et les valeurs aberrantes dans nos données. Nous verrons qu'une façon de faire assez classique consiste à comparer la distribution d'une variable quantitative pour les différents niveaux d'une variable catégorielle.


## La grammaire des graphiques {#gggraph}

Les lettres `gg` du package `ggplot` sont l'abbréviation de "grammar of graphics" : la grammaire des graphiques. De la même manière que nous construisons des phrases en respectant des règles grammaticales précises (usage des noms, des verbes, des sujets et adjectifs...), la grammaire des graphiques établit un certain nombre de règles permettant de construire des graphiques : elle précise les composants d'un graphique en suivant le cadre théorique défini par @wilkinson2005.


### Éléments de la grammaire

En bref, la grammaire des graphiques nous dit que : 

> Un graphique est l'association (`mapping`) de données/variables (`data`) à des attributs esthétiques (`aes`thetics) d'objets géométriques (`geom`etric objects).

Pour clarifier, on peut disséquer un graphique en 3 éléments esentiels :

1. `data` : le jeu de données contenant les variables que l'on va associer à des objets géométriques
2. `geom` : les objets géométriques en question. Cela fait référence aux types d'objets que l'on peut observer sur le graphiques (des points, des lignes, des barres, etc)
3. `aes` : les attributs esthétiques des objets géométriques présents sur le graphique. Par exemple, la position sur les axes `x` et `y`, la couleur, la taille, la transparence, la forme, etc. Chacun de ces attributs esthétiques peut-être associé à une variable de notre jeu de données.

Examinons un exemple pour bien comprendre.

### Gapminder

En février 2006, un statisticien du nom de Hans Rosling a donné un TED Talk intitulé "[The best stats you'we ever seen](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen)". Au cours de cette conférence, Hans Rosling présente des données sur l'économie mondiale, la santé et le développement des pays du monde. Les données sont disponibles [sur ce site](https://www.gapminder.org/tools/#$chart-type=bubbles) et dans [le package `gapminder`](https://cran.r-project.org/web/packages/gapminder/index.html).

Pour l'année 2007, le jeu de données contient des informations pour 142 pays. Examinons les premières lignes de ce jeu de données :

```{r echo=FALSE}
library(gapminder)
gapminder_2007 <- gapminder %>% 
  filter(year == 2007) %>% 
  select(-year) %>% 
  rename_all(str_to_title) %>% 
  rename(`Life Expectancy` = Lifeexp,
         `GDP per Capita` = Gdppercap,
         Population = Pop)

gapminder_2007 %>% 
  head() %>% 
  knitr::kable(caption = "Les 6 premières lignes du jeu de données `gapminder` pour l'année 2007")
```

Pour chaque ligne, les variables suivantes sont décrites : 

- `Country` : le pays
- `Continent` : le continent
- `Life Expectancy` : espérance de vie à la naissance
- `Population` : nombre de personnes vivant dans le pays
- `GDP per Capita` : produit intérieur brut (PIB) par habitant en dollars américains. GDP est l'abréviation de "Growth Domestic Product". C'est un indicateur de l'activité économique d'un pays, parfois utilisé comme une approximation du revenu moyen par habitant.

Examinons maintenant la figure \@ref(fig:gapminder_fig) qui représente ces variables pour chacun des 142 pays de ce jeu de données (notez l'utilisation de la notation scientifique dans la légende).

```{r gapminder_fig, echo=FALSE, fig.cap="Espérance de vie en fonction du PIB par habitant en 2007"}
gapminder_2007 %>% 
  ggplot(aes(x = `GDP per Capita`, y = `Life Expectancy`, color = Continent, size = Population)) + 
    geom_point()
```

Si on décrypte ce graphique du point de vue de la grammaire des graphiques, on voit que :

- la variable `GDP per Capita` est associée à l'`aes`thetic `x` de la position des points
- la variable `Life Expectancy` est associée à l'`aes`thetic `y` de la position des points
- la variable `Population` est associée à l'`aes`thetic `size` (taille) des points
- la variable `Continent` est associée à l'`aes`thetic `color` (couleur) des points

Ici, l'objet géométrique (ou `geom`) qui représente les données est le point. Les données (ou `data`) sont contenues dans le tableau `gapminder` et chaune de ces variables est associée (`mapping`) aux caractéristiques esthétiques des points.


### Autres éléments de la grammaire des graphiques

Outre les éléments indispensables évoqués ici (`data`, `mapping`, `aes`, et `geom`), il existe d'autres aspects de la grammaire des graphiques qui permettent de contrôler l'aspect des graphiques. Ils ne sont pas toujours indispensables. Nous en verrons néanmoins quelque-uns particulièrement utiles : 

- `facet` : c'est un moyen très pratique de scinder le jeu de données en plusieurs sous-groupe et de produire automatiquement un graphique pour chacun d'entre eux.
- `position` : permet notamment de modifier la position des barres d'un barplot.
- `labs` : permet de définir les titres, sous-titres et légendes des axes d'un graphique
- l'ajustement du système de coordonnées.
- `theme` : permet de modifier l'apect général des graphiques en appliquant des thèmes prédéfinis ou en modifiant certains aspects de thèmes existants


### Le package `ggplot2`

Comme indiqué plus haut, le package `ggplot2` [@R-ggplot2] permet de réaliser des graphiques dans R en respectant les principes de la grammaire des graphiques. Vous avez probablement remarqué que depuis le début de la section \@ref(gggraph), beaucoup de termes sont écrits dans la police réservée au `code` informatique. C'est parce que les éléments de la grammaire des graphiques sont tous précisés dans la fonction `ggplot()` qui demande, au grand minimum, que les éléments suivants soient spécifiés :

- le nom du `data.frame` contenant les variables qui seront utilisées pour le graphique. Ce nom correspond à l'argument `data` de la fonction `ggplot()`.
- l'association des variables à des attributs esthétiques. Cela se fait grâce à l'argument `mapping` et la fonction `aes()`

Après avoir spécifié ces éléments, on ajoute des couches supplémentaires au graphique grâce au signe `+`. La couche la plus essentielle à ajouter à un graphique, est une couche contenant un élément géométrique, ou `geom` (par exemple des points, des lignes ou des barres). D'autres couches peuvent s'ajouter pour spécifier des titres, des `facet`s ou des modifications des axes et des thèmes du graphique.

Dans le cadre de ce cours, nous nous limiterons aux 5 types de graphiques suivants : 

1. les nuages de points
2. les graphiques en lignes
3. les boîtes à moustaches ou boxplots
4. les histogrammes
5. les diagrammes bâtons


## Les nuages de points

C'est probablement le plus simple des 5 types de graphiques citées plus haut. Il s'agit de graphiques bi-variés pour lesquels une variable est associée à l'axe des abscisses, et une autre est associée à l'axe des ordonnées. Comme pour le graphique présenté à la figure \@ref(fig:gapminder_fig) ci-dessus, d'autres variables peuvent être associées à des caractéristiques esthétiques des points (transparence, taille, couleur, forme...).

Nous allons ici nous intéresser à la relation qui existe entre :

1. `dep_delay` : le retard des vols au décollage, que nous placerons sur l'axe des "x"
2. `arr_delay` : le retard des mêmes vols à l'aterrissage, que nous placerons sur l'axe des "y"

Afin d'avoir un jeu de données plus facile à utiliser, nous nous contenterons de visualiser les vols d'Alaska Airline, donc le code de compagnie aérienne est `"AS"`.

```{r tidy=FALSE}
alaska_flights <- flights %>%
  filter(carrier == "AS")
```

Il est normal que vous ne compreniez pas encore les commandes ci-dessous. Nous verrons ça plus tard. Retenez juste que nous avons maintenant créer un nouveau tableau, nommé `alaska_flights`, qui contient toutes les informations des vols d'Alaska Airline. Commencez par examiner ce tableau avec la fonction `View()`. En quoi est-il différent du tableau `flights` ?

### La couche de base : la fonction `ggplot()`

La fonction `ggplot()` permet d'établir la première base du graphique. C'est grâce à cette fonction que l'on précise quel jeu de données utiliser et quelle variables placer sur les axes :

```{r fig.cap="Un graphique sans `geom`"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay))
```

Ce graphique est pour le moins vide : c'est normal, nous n'avons pas encore spéifié la couche contenant l'objet géométrique que nous souhaitons utiliser. 

### Ajout d'une couche supplémentaire : l'objet géométrique

Les nuages de points sont créés par la fonction `geom_point()` :

```{r fig.cap="Retards à l'arrivée en fonction des retard au décollage pour les vols d'Alaska Airline au départ de New York City en 2013", tidy=FALSE}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) + 
  geom_point()
```

plusieurs choses importantes sont à remarquer ici :

1. le graphique présente maintenant une couche supplémentaire constituée de points.
2. la fonction `geom_point()` nous prévient que 5 lignes contenant des données manquantes n'ont pas été intégrées au graphique. Les données manquent soit pour une variable, soit pour l'autre, soit pour les 2. il est donc impossible de les faire apparaître sur le graphique.
3. il existe une relation positive entre `dep_delay` et `arr_delay` : quand le retard d'un vol au décollage augmente, le retard de ce vol augmente aussi à l'arrivée.
4. Enfin, il y a une grande majorité de points centrés près de l'origine (0,0).

Si je résume cette syntaxe :

- Au sein de la fonction `ggplot()`, on spécifie 2 composants de la grammaire des graphiques :
    1. le nom du tableau contenant les données grâce à l'argument `data = alaska_flights`
    2. l'association (`mapping`) des variables à des caractéristiques esthétiques (`aes()`) en précisant `aes(x = dep_delay, y = arr_delay)` :
        - la variable `dep_delay` est associée à l'esthétique de position `x`
        - la variable `arr_delay` est associée à l'esthétique de position `y`
- On ajoute une couche au graphique `ggplot()` grâce au symbole `+`. La couche en question précise le troisème élément indispensable de la grammaire des graphiques : l'objet `geom`étrique. Ici, les objets sont des `point`s. On le spécifie grâce à la fonction `geom_point()`.

Quelques remarques concernant les couches :

- Notez que le signe `+` est placé *à la fin de la ligne*. Vous recevrez un message d'erreur si vous le placez au début.
- Quand vous ajoutez une couche à un graphique, je vous encourage vivement à presser la touche `enter` de votre clavier juste après le symbole `+`. Ainsi, le code correspondant à chaque couche sera sur une ligne distincte, ce qui augmente considérablement la lisibilité de votre code.
- Comme indiqué dans la section \@ref(functions), tant que les arguments d'une fonction sont spécifiés dans l'ordre, on peut se passer d'écrire leur nom. Ainsi, les deux blocs de commande suivants produisent exactement le même résultat :

```{r eval=FALSE, tidy=FALSE}
# Le nom des arguments est précisé
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) + 
  geom_point()

# Le nom des arguments est omis
ggplot(alaska_flights, aes(x = dep_delay, y = arr_delay)) + 
  geom_point()
```


### Exercices

1. Donnez une raison pratique expliquant pourquoi les variables `dep_delay` et `arr_delay` ont une relation positive
2. Quelles variables (pas nécessairement dans le tableau `alaska_flights`) pourraient avoir une corrélation négative (relation négative) avec `dep_delay` ? Pourquoi ? Rappelez-vous que nous étudions ici des variables numériques.
3. Selon vous, pourquoi tant de points sont-il regroupés près de (0, 0) ? À quoi le point (0,0) correspond-il pour les vols d'Alaska Airline ?
4. Citez les éléments de ce graphique/de ces données qui vous sautent le plus aux yeux ?
5. Créez un nouveau nuage de points en utilisant d'autres variables du jeu de données `alaska_flights`


### Over-plotting

L'over-plotting est la superposition importante d'une grande quantité d'information sur une zone restreinte d'un graphique. Dans notre cas, nous observons un over-plotting important autour de (0,0). Cet effet est gênant car il est difficile de se faire une idée précise du nombre de points accumulés dans cette zone. La façon la plus simple de régler le problème est de modifier la transparence grâce à l'argument `alpha` de la fonction `geom_point()`. Par défaut, cette valeur est fixée à 1, pour une opacité totale. Une valeur de 0 rend les points totalement transparents, et donc invisibles. Trouver la bonne valeur peut demander de tâtonner une peu :

```{r tidy=FALSE, warning = FALSE, fig.cap="La même figure, avec des points semi-transparents"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) + 
  geom_point(alpha = 0.2)
```

Notez que :

- la transparence est additive : plus il y a de points, plus la zone est foncée car les points se superposent et rendent la zone plus opaque.
- l'argument `alpha = 0.2` n'est pas intégré à l'intérieur d'une fonction `aes()` car il n'est pas associé à une variable : c'est un simple paramètre.

L'over-plotting est souvent rencontré lorsque l'on représente plusieurs nuages de points pour les différentes valeurs d'une variable catégorielle. par exemple, si on transforme les mois de l'année en facteur (`factor(month)`), ont peut regarder s'il existe une relation entre les retards à l'aterrissage et le mois de l'année :

```{r tidy=FALSE, warning=FALSE, fig.cap="Retards à l'arrivée pour les 12 mois de l'année 2013"}
ggplot(data = alaska_flights, mapping = aes(x = factor(month), y = arr_delay)) +
  geom_point()
```

Ici, l'ajout de transparence ne serait pas suffisant. Une autre solution est d'appliquer la mothode dîte de "jittering", ou tremblement. Elle consiste à ajouter un bruit aléatoire horizontal et/ou vertical aux points d'un graphique. Ici, on peut ajouter un léger bruit horizontal afin de disperser un peu les points pour chaque mois de l'année. On n'ajoute pas de bruit vertical car on ne souhaite pas que les valeurs de retard (sur l'axe des `y`) soient altérées :

```{r jittering, tidy=FALSE, warning=FALSE, fig.cap="Retards à l'arrivée pour les 12 mois de l'année 2013"}
ggplot(data = alaska_flights, mapping = aes(x = factor(month), y = arr_delay)) +
  geom_jitter(width = 0.25)
```

On y voit déjà plus clair. L'argument `width` permet de spécifier l'intensité de la dispersion horizontale. Pour ajouter du bruit vertical (ce qui n'est pas souhaitable ici !), on peut ajouter l'argument `height`. le graphique de la figure \@ref(fig:jittering) est parfois appelé un "stripchart". C'est un graphique du type "nuage de points", mais pour lequel l'une des 2 variables et numérique, et l'autre est catégorielle.

Il est évidemment possible d'ajouter de la transparence : 

```{r tidy=FALSE, warning=FALSE, fig.cap="Retards à l'arrivée pour les 12 mois de l'année 2013"}
ggplot(data = alaska_flights, mapping = aes(x = factor(month), y = arr_delay)) +
  geom_jitter(width = 0.25, alpha = 0.5)
```


### Couleur, taille et forme

L'argument `color` (ou `colour`, les deux orthographes fonctionnent) permet de spécifier la couleur des points. L'argument `size` permet de spécifier la taille des points. L'argument `shape` permet de spécifier la forme utilisée en guise de symbole. Ces 3 arguments peuvent être utilisés comme des paramètres, pour modifier l'ensemble des points d'un graphique. Mais ils peuvent aussi être associés à une variable, pour apporter une information supplémentaire.

Comparez les deux graphiques suivants :

```{r, rightcolor, tidy=FALSE, warning=FALSE, fig.cap="Utilisation correcte de `color`"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(color = "blue")
```

```{r, wrongcolor, tidy=FALSE, warning=FALSE, fig.cap="Utilisation incorrecte de `color`"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(aes(color = "blue"))
```

Le code qui permet de produire la figure \@ref(fig:rightcolor) fait un usage correct de l'argument `color`. On demande des points de couleur bleue, les points apparaîssent bleus. La figure \@ref(fig:wrongcolor) en revanche ne produit pas le résultat attendu. Puisque nous avons mis l'argument `color` à l'intérieur de la fonction `aes()`, R s'attend à ce que la couleur soit associée à une variable. Puisqu'aucune variable ne s'appelle "blue", R utilise la couleur par défaut. Pour associer la couleur des points à une variable, nous devons fournir un nom de variable valide :

```{r, varcolor, tidy=FALSE, warning=FALSE, fig.cap="Association de `color` à une variable catégorielle"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(aes(color = factor(month)))
```

Ici, l'utilisation de la couleur est correcte. Elle est associée à une variable catégorielle, et chaque valeur possible du vecteur `month` se voit donc attribuer une couleur différente.

```{r, varcolor2, tidy=FALSE, warning=FALSE, fig.cap="Association de `color` à une variable numérique"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(aes(color = arr_time))
```

De la même façon, la couleur des points est ici associée à une variable continue (l'heure d'arrivée des vols). Les points se voient donc attribuer une couleur choisie le long d'un gradient.

La même approche peut être utilisée pour spécifier la forme des symboles avec l'argument `shape`. Attention toutefois : une variable continue ne peut pas être associée à `shape`

```{r, shapeplot, tidy=FALSE, warning=FALSE, fig.cap="Association de `shape` à un facteur"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(aes(shape = factor(month)))
```

Vous noterez que seuls les 6 premiers niveaux d'un facteur se voient attribuer une forme automatiquement. Au delà de 6 symboles différents sur un même graphique, le résultat est souvent illisible. Il est possible d'ajouter plus de 6 symboles, mais cela demande de modifier la légende manuellement et concrètement nous n'en aurons jamais besoin. Lorsque plus de 6 séries doivent être distinguées, d'autres solutions bien plus pertinentes (par exemple les `factet`s) devraient être utilisées.

Comme pour la couleur, il est possible d'e spécifier'utiliser l'argument `shape` en tant que paramètre du graphique sans l'associer à une variable. Il faut alors fournir un code compris entre 0 et 24 :

```{r, shapeplot2, tidy=FALSE, warning=FALSE, fig.cap="Utilisation de `shape` en tant que paramètre"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(shape = 4)
```

Notez qu'ici, `ggplot()` ne crée pas de légende : tous les points ont le même symbole, ce symbole n'est pas associé à une variable, une légende est donc inutile.

Parmis les valeur possibles pour `shape`, les symboles 21 à 24 sont des symboles dont on peut spécifier séparément la couleur du contour, avec `color` et la couleur du fond avec `fill` :

```{r, shapecolorplot, tidy=FALSE, warning=FALSE, fig.cap="Utilisation de `shape`, `color` et `fill`"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(shape = 21, fill = "steelblue", color = "orange", alpha = 0.5)
```

N'hésitez pas à zoomer pour bien observer les points et comprendre ce qui se passe. Un conseil, faites des choix raisonnables ! Trop de couleurs n'est pas forcément souhaitable.

Enfin, on peut ajuster la taille des symboles avec l'argument `size`. Tout comme il n'est pas possible d'associer une variable continue à `shape`, et il n'est pas conseillé d'associer une variable catégorielle nominale (c'est à dire un facteur non ordonné) à `size`. Associer une variable continue est en ravanche parfois utile :

```{r, sizeplot, tidy=FALSE, warning=FALSE, fig.cap="Association d'une variable continue à la taille des symboles avec l'argument `size`"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(aes(size = arr_time), alpha = 0.1)
```

Si l'over-plotting est ici très important (c'est pourquoi j'ai utilisé `alpha`), on constate néanmoins que les vols avec les retards les plus importants sont presque tous arrivés très tôt dans la journée ("500" signifie 5h00 du matin). Il s'agit probablement de vols qui devaient arriver dans la nuit, avant minuit, et qui sont finalement arrivés en tout début de journée, etnre 00h01 et 5h00 du matin. Comme pour les autres arguments, il est possible d'utiliser `size` avec une valeur fixe, la même pour tous les symboles, lorsque cet argument n'est pas associé à une variable.

Enfin un conseil : évitez de trop surcharger vos graphiques. En combinant l'ensemble de ces arguments, il est malheureusement très facile d'obtenir des graphiques peu lisibles, ou contenant tellement d'information qu'ils en deviennent difficiles à déchiffrer. Faites preuve de modération :

```{r, badplot, tidy=FALSE, warning=FALSE, fig.cap="Sometimes, less is more!"}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay, size = arr_time)) +
  geom_point(alpha = 0.6, 
             shape = 22,
             color = "orange",
             fill = "steelblue",
             stroke = 2)
```


### Exercices

À quoi sert l'argument `stroke` ?

Avec le jeu de données `diamonds`, tapez le code permettant de créer le graphique \@ref(fig:exodiamonds) (Indice : affichez le tableau `diamonds` dans la console afin de voir quelles sont les variables disponibles).

```{r, exodiamonds, tidy=FALSE, warning=FALSE, echo = FALSE, fig.cap="Prix de 53940 diamants en fonction de leur taille en carats et de leur couleur."}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
    geom_point(alpha = 0.5, shape = 4, aes(color = color))
```

Selon vous, à quoi sont dues les bandes verticales que l'on observe sur ce graphique ?


## Graphiques en lignes

